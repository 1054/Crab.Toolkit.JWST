#!/bin/bash
# 

usage() {
    echo "Usage: "
    echo "  go-run-screen-jobs-in-parallel.bash go_qsub_script.bash"
    echo "Options: "
    echo "  -nparallel 9 # this defines the number of parallel processes (GNU screens)."
    echo "Notes: "
    echo "  This runs the qsub script with GNU screen in parallel."
    echo "  The qsub script is generated by \"go-qsub-jwst-imaging-jobarray-group.bash\"."
}

check_integer () {
    if [[ $(echo "$1" | perl -p -e 's/^[0-9]+$/999999/g') == "999999" ]]; then
        return 0
    else 
        return 1
    fi
}

iarg=1
argstr=""
argoption=""
script_file="" # ./go_qsub_processing_jwst_imaging_20230422_00h04m35s.bash
max_concurrent=9
while [[ $iarg -le $# ]]; do
    argstr="${!iarg}"
    if [[ "$argstr" == "-"* ]]; then
        argoption=$(echo "$argstr" | perl -p -e 's/^[-]+/-/g' | tr [:upper:] [:lower:])
        if [[ "$argstr" == "-nparallel" ]]; then
            iarg=$((iarg+1))
            if [[ $iarg -le $# ]]; then
                argstr="${!iarg}"
                if check_integer "$argstr"; then
                    max_concurrent="$argstr"
                else
                    echo "Error! The argument followed by the option -nparallel should be an integer: \"$argstr\""
                    exit 255
                fi
            fi
        fi
    else
        if [[ x"$script_file" == x"" ]]; then
            script_file="${!iarg}"
        fi
    fi
    iarg=$((iarg+1))
done

if [[ x"$script_file" == x"" ]]; then
    usage
    exit
fi

echo "script_file = $script_file"
echo "max_concurrent = $max_concurrent"
if [[ ! -f $script_file ]]; then
    echo "Error! The input script file does not exist: \"$script_file\""
    exit 255
fi
chmod +x $script_file
#exit


timestamp=$(date +"%Y%m%d_%Hh%Mm%Ss")
process_prefix=batch_go_run_qsub_script
n_groups=$(cat $script_file | grep '^ngroups=' | perl -p -e 's/^ngroups=([0-9]+)/\1/g')
if [[ x"$n_groups" == x"" ]] || [[ x"$n_groups" == x"ngroups"* ]]; then
    echo "Error! Could not read ngroups from \"$script_file\"!"
    exit 255
fi
sleep_level=1

for (( i=0; i<$n_groups; i++ )); do
    export PBS_ARRAYID=$((i+1))
    sleep 0.5
    sleep_level=1
    while [[ $(screen -ls | grep ".$process_prefix." | wc -l) -gt $max_concurrent ]]; do
        sleep $(awk "BEGIN {print 2**($sleep_level);}")
        if [[ $sleep_level -lt 5 ]]; then
            sleep_level=$((sleep_level+1))
        fi
    done
    echo "logfile log_$process_prefix.$PBS_ARRAYID.txt" > log_$process_prefix.$PBS_ARRAYID.conf
    echo "logfile flush 1" >> log_$process_prefix.$PBS_ARRAYID.conf
    echo "log on" >> log_$process_prefix.$PBS_ARRAYID.conf
    echo "screen -d -m -S \"$process_prefix.$PBS_ARRAYID\" -L -c \"log_$process_prefix.$PBS_ARRAYID.conf\" $script_file"
    screen -d -m -S "$process_prefix.$PBS_ARRAYID" -L -c "log_$process_prefix.$PBS_ARRAYID.conf" $script_file
    sleep 1.5
done

